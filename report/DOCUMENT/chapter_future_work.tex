\chapter{Επίλογος}
\label{ch:conclusion}
Σε αυτή τη διπλωματική εργασία μελετήσαμε το πρόβλημα εύρεσης της 
Ευκλείδειας απόστασης δύο τριγωνικών πλεγμάτων.

Στη μεθοδολογία που ακολουθήσαμε, σχεδιάσαμε μια δομή δεδομένων που 
ανήκει στην οικογένεια των Ιεραρχιών Οριοθετικών Όγκων, το \tl{sKD-Tree}, 
και προτείναμε δύο αλγορίθμους που κάνουν χρήση αυτής της δομής.
Οι αλγόριθμοι που σχεδιάσαμε γενικεύονται και για άλλα ήδη πλεγμάτων 
πέραν των τριγωνικών, υπό τις προϋποθέσεις του κεφαλαίου \ref{ch:methodology}.
Στη συνέχεια παρουσιάσαμε τα αποτελέσματα της εφαρμογής των αλγορίθμων 
μας σε μια σειρά από σενάρια ελέγχου που κατασκευάσαμε.
Με τα παραπάνω αποτελέσματα περιγράφουμε την επίδοση 
των αλγορίθμων ανά σενάριο, και ταυτόχρονα κάνουμε τη σύγκριση μεταξύ 
τους.

Σε αυτό το κεφάλαιο, θα σχολιάσουμε τα αποτελέσματα και θα προτείνουμε 
τη μελλοντική εργασία που μπορεί να επεκτείνει την παρούσα διπλωματική 
εργασία.

\section{Συμπεράσματα}
Ξεκινώντας από το διάγραμμα του σχήματος \ref{fig:build_time} με τους 
χρόνους κατασκευής του \tl{sKD-Tree} παρατηρούμε ότι η διαδικασία 
της κατασκευής δεν μπορεί να επιταχυνθεί γραμμικά σε σχέση με το πλήθος 
των νημάτων που χρησιμοποιούνται.
Αυτό προκύπτει από το γεγονός ότι δεν μπορούμε να εκμεταλλευτούμε όλα τα 
νήματα από την αρχή.
Συγκεκριμένα για κάθε κόμβο του δέντρου πρώτα γίνεται ο διαχωρισμός 
των τριγώνων σε δύο υποσύνολα, το οποίο γίνεται σειριακά,
και έπειτα η κατασκευή του αριστερού και δεξιού παιδιού παράλληλα.
Επομένως, για την κατασκευή της ρίζας μπορούμε να εκμεταλλευτούμε
μόνο δύο νήματα, ενώ για το δεύτερο επίπεδο του δέντρου μόνο 4 και 
ούτω καθεξής. 
Έτσι τα νήματα παραμένουν αδρανή στα πρώτα επίπεδα χτισίματος του 
δέντρου.
Επίσης, παρατηρούμε ότι η επιπλέον επιτάχυνση που επιτυγχάνεται 
για κάθε επιπλέον νήμα που προστίθεται είναι όλο και μικρότερη 
(πίνακας \ref{tab:build_acceleration}). 

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline 
         & 1 \tl{thread} & 2 \tl{threads} & 4 \tl{threads} & 8 \tl{threads} \\
        \hline
        Επιτάχυνση & $\times1$ & $\times 1.40$ & $\times 1.92$ & $\times 2.14$ \\
        \hline
    \end{tabular}
    \caption[]{Επιτάχυνση κατασκευής του \tl{sKD-Tree} συναρτήσει των νημάτων}
    \label{tab:build_acceleration}
\end{table}

Σύμφωνα με τα παραπάνω, και για τα μεγέθη των πλεγμάτων που χρησιμοποιήθηκαν, 
ο χρόνος κατασκευής του δέντρου με τέσσερα νήματα, πρακτικά, δε διαφέρει 
από τον χρόνο κατασκευής με οκτώ. 
Με αφορμή αυτή την παρατήρηση και το γεγονός ότι ο αλγόριθμος \ref{alg:queries_on_tree}
έχει έναν παράγοντα τυχαιότητας, σχεδιάσαμε τον αλγόριθμο \ref{alg:search_on_two_trees}
που χρησιμοποιεί δύο \tl{sKD-Tree}.
Ο αλγόριθμος αυτός εκτελεί την αναζήτηση με συγκεκριμένη σειρά, οπότε δεν είναι τυχαίος,
ενώ η προεπεξεργασία μπορεί να πραγματοποιηθεί στον ίδιο, πρακτικά, χρόνο εάν τα 
δύο δέντρα κατασκευαστούν παράλληλα.

Στόχος του αλγορίθμου \ref{alg:search_on_two_trees} ήταν να επιτυγχάνει πολύ 
μικρό κόστος αναζήτησης. 
Ιδανικά μια διάσχιση του πρώτου δέντρου και μια του δεύτερου, δηλαδή πολυπλοκότητα 
της τάξης $\bigO(log(N) + log(M))$ ή $\bigO(log(N) * log(M))$ στη 
μέση περίπτωση.
Ο αλγόριθμος \ref{alg:search_on_two_trees} επιτυγχάνει αρκετά μικρότερο κόστος 
αναζήτησης από τον \ref{alg:queries_on_tree} μόνο στις περιπτώσεις 
που τα αντικείμενα συγκρούονται ή όταν απέχουν αρκετά.
Όμως, ακόμη και σε αυτές τις περιπτώσεις, η διαφορά στο χρόνο αναζήτησης 
δεν είναι μεγάλη, καθώς για τα σενάρια μας αυτή 
ήταν από $50ms$ έως $200ms$ (σχήμα \ref{fig:search_time_vs_distance}).
Σε όλες τις άλλες περιπτώσεις το κόστος αναζήτησης του αλγορίθμου 
\ref{alg:search_on_two_trees} ήταν χειρότερο από αυτό του \ref{alg:queries_on_tree}.
Επιπλέον, από τα διαγράμματα του κεφαλαίου \ref{sec:profiling} προκύπτει τελικά 
ότι το ποσοστό του χρόνου αναζήτησης για τον αλγόριθμο \ref{alg:queries_on_tree}
είναι μικρό (περίπου $6\% - 15\%$) στη μέση περίπτωση.
Επομένως, εξίσου μικρά είναι και τα περιθώρια βελτίωσης του χρόνου αναζήτησης.

Τελικά, με βάση όλα όσα αναφέρθηκαν παραπάνω, ο αλγόριθμος \ref{alg:queries_on_tree} 
που χρησιμοποιεί ένα \tl{sKD-Tree} και εκτελεί παράλληλα ερωτήματα κοντινότερου 
γείτονα φαίνεται να είναι ο προτιμότερος.


\section{Μελλοντική Εργασία}
Κλείνοντας αυτή την εργασία, θα αναφέρουμε κάποιες κατευθύνσεις που μπορούν 
να επεκτείνουν ή και να βελτιώσουν την προτεινόμενη μεθοδολογία.

Αρχικά, όπως αναφέρθηκε παραπάνω, το μεγαλύτερο ποσοστό του χρόνου εκτέλεσης 
καταλαμβάνεται από την κατασκευή του δέντρου. 
Πιθανόν, η σχεδίαση αλγορίθμων κατασκευής του \tl{sKD-Tree} υλοποιημένοι 
για \tl{GPU} να μειώσουν τον χρόνο προεπεξεργασίας.
Επιπλέον, αξίζει και η έρευνα για τη σχεδίαση αλγορίθμων που εκτελούν παράλληλα 
ερωτήματα στο δέντρο, υλοποιημένοι για \tl{GPU}.

Για τον αλγόριθμο \ref{alg:queries_on_tree}, κατά τα πειράματα, παρατηρήθηκε ότι 
η επιλογή του αντικειμένου στο οποίο κατασκευάζεται το \tl{sKD-Tree} έχει 
επίδραση στον συνολικό χρόνο εκτέλεσης.
Επομένως, η χρήση κάποιας ευρετικής μεθόδου ικανή να "προβλέπει" γρήγορα
σε ποιο αντικείμενο αξίζει να κατασκευαστεί το δέντρο, μπορεί να βελτιώσει 
τον συνολικό χρόνο εκτέλεσης του αλγορίθμου. 
Μια μέθοδος που φαίνεται να λειτουργεί σωστά, όταν το μέγεθος των τριγώνων 
των δύο μοντέλων είναι παρόμοιο, βασίζεται στην \tl{SAH}.
Δηλαδή, τον λόγο του πλήθους των τριγώνων του μοντέλου προς το εμβαδόν 
της επιφάνειας του \tl{AABB} του. 
Η επιλογή κατασκευής του δέντρου στο αντικείμενο με τη μεγαλύτερη τιμή 
του παραπάνω λόγου φαίνεται να λειτουργεί σωστά, χωρίς όμως να έχουμε 
επαρκή δεδομένα για να το επιβεβαιώσουμε.

Τέλος, θεωρούμε πως αξίζει να διερευνηθεί η χρήση διαφορετικών οριοθετικών 
όγκων, πέραν των \tl{AABB} και να γίνει σύγκριση του συνολικού χρόνου εκτέλεσης
των αλγορίθμων.
Ιδιαίτερο ενδιαφέρον έχουν τα \tl{OBB, LSS} και \tl{RSS}.



