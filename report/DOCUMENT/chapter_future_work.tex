\chapter{Επίλογος}
\label{ch:conclusion}
Σε αυτή τη διπλωματική εργασία μελετήσαμε το πρόβλημα εύρεσης της 
Ευκλείδειας απόστασης δύο τριγωνικών πλεγμάτων.

Στη μεθοδολογία που ακολουθήσαμε, σχεδιάσαμε μια δομή δεδομένων που 
ανήκει στην οικογένεια των Ιεραρχιών Οριοθετικών Όγκων, το \tl{sKD-Tree}, 
και προτείναμε δύο αλγορίθμους που κάνουν χρήση αυτής της δομής.
Οι αλγόριθμοι που σχεδιάσαμε γενικεύονται και για άλλα ήδη πλεγμάτων 
πέραν των τριγωνικών, υπό τις προϋποθέσεις που στο κεφάλαιο \ref{ch:methodology}.
Στη συνέχεια παρουσιάσαμε τα αποτελέσματα της εφαρμογής των αλγορίθμων 
μας σε μια σειρά από σενάρια ελέγχου που κατασκευάσαμε.
Με τα παραπάνω αποτελέσματα περιγράφουμε την επίδοση 
των αλγορίθμων ανά σενάριο, και ταυτόχρονα κάνουμε τη σύγκριση μεταξύ 
τους.

Σε αυτό το κεφάλαιο, θα σχολιάσουμε τα αποτελέσματα και θα προτείνουμε 
τη μελλοντική εργασία που μπορεί να επεκτείνει την παρούσα διπλωματική 
εργασία.

\section{Συμπεράσματα}
Ξεκινώντας από το διάγραμμα του σχήματος \ref{fig:build_time} με τους 
χρόνους κατασκευής του \tl{sKD-Tree} παρατηρούμε ότι η διαδικασία 
της κατασκευής δεν μπορεί να επιταχυνθεί γραμμικά σε σχέση με το πλήθος 
των νημάτων που χρησιμοποιούνται.
Αυτό προκύπτει από το γεγονός ότι δεν μπορούμε να εκμεταλλευτούμε όλα τα 
νήματα από την αρχή.
Συγκεκριμένα για κάθε κόμβο του δέντρου πρώτα γίνεται ο διαχωρισμός 
των τριγώνων σε δύο υποσύνολα, το οποίο γίνεται σειριακά,
και έπειτα η κατασκευή του αριστερού και δεξιού παιδιού παράλληλα.
Επομένως, για την κατασκευή της ρίζας μπορούμε να εκμεταλλευτούμε
μόνο δύο νήματα, ενώ για το δεύτερο επίπεδο του δέντρου μόνο 4 και 
ούτω καθεξής. 
Έτσι τα νήματα παραμένουν αδρανή στα πρώτα επίπεδα χτισίματος του 
δέντρου.
Επίσης, παρατηρούμε ότι η επιπλέον επιτάχυνση που επιτυγχάνεται 
για κάθε επιπλέον νήμα που προστίθεται είναι όλο και μικρότερη 
(πίνακας \ref{tab:build_acceleration}). 

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline 
         & 1 \tl{thread} & 2 \tl{threads} & 4 \tl{threads} & 8 \tl{threads} \\
        \hline
        Επιτάχυνση & $\times1$ & $\times 1.40$ & $\times 1.92$ & $\times 2.14$ \\
        \hline
    \end{tabular}
    \caption[]{Επιτάχυνση κατασκευής του \tl{sKD-Tree} συναρτήσει των νημάτων}
    \label{tab:build_acceleration}
\end{table}

Σύμφωνα με τα παραπάνω, και για τα μεγέθη των πλεγμάτων που χρησιμοποιήθηκαν, 
ο χρόνος κατασκευής του δέντρου με τέσσερα νήματα, πρακτικά, δε διαφέρει 
από τον χρόνο κατασκευής με οκτώ. 
Με αφορμή αυτή την παρατήρηση και το γεγονός ότι ο αλγόριθμος \ref{alg:queries_on_tree}
έχει έναν παράγοντα τυχαιότητας, σχεδιάσαμε τον αλγόριθμο \ref{alg:search_on_two_trees}
που χρησιμοποιεί δύο \tl{sKD-Tree}.
Ο αλγόριθμος αυτός εκτελεί την αναζήτηση με συγκεκριμένη σειρά, οπότε δεν είναι τυχαίος,
ενώ η προεπεξεργασία μπορεί να πραγματοποιηθεί στον ίδιο, πρακτικά, χρόνο εάν τα 
δύο δέντρα κατασκευαστούν παράλληλα.

Στόχος του αλγορίθμου \ref{alg:search_on_two_trees} ήταν να επιτυγχάνει πολύ 
μικρό κόστος αναζήτησης. 
Ιδανικά μια διάσχιση του πρώτου δέντρου και μια του δεύτερου, δηλαδή πολυπλοκότητα 
της τάξης $\bigO(log(N) + log(M))$ ή $\bigO(log(N) * log(M))$ στη 
μέση περίπτωση.
Ο αλγόριθμος \ref{alg:search_on_two_trees} επιτυγχάνει αρκετά μικρότερο κόστος 
αναζήτησης από τον \ref{alg:queries_on_tree} μόνο στις περιπτώσεις 
που τα αντικείμενα συγκρούονται ή όταν απέχουν αρκετά.
Όμως, ακόμη και σε αυτές τις περιπτώσεις, η διαφορά στο χρόνο αναζήτησης 
δεν είναι μεγάλη, καθώς για τα σενάρια μας αυτή 
ήταν από $50ms$ έως $200ms$ (σχήμα \ref{fig:search_time_vs_distance}).
Σε όλες τις άλλες περιπτώσεις το κόστος αναζήτησης του αλγορίθμου 
\ref{alg:search_on_two_trees} ήταν χειρότερο από αυτό του \ref{alg:queries_on_tree}.
Επιπλέον, από τα διαγράμματα του κεφαλαίου \ref{sec:profiling} προκύπτει τελικά 
ότι το ποσοστό του χρόνου αναζήτησης για τον αλγόριθμο \ref{alg:queries_on_tree}
είναι μικρό (περίπου $6\% - 15\%$) στη μέση περίπτωση.
Επομένως, εξίσου μικρά είναι και τα περιθώρια βελτίωσης του χρόνου αναζήτησης.

Τελικά, με βάση όλα όσα αναφέρθηκαν παραπάνω, ο αλγόριθμος \ref{alg:queries_on_tree} 
που χρησιμοποιεί ένα \tl{sKD-Tree} και εκτελεί παράλληλα ερωτήματα κοντινότερου 
γείτονα φαίνεται να είναι ο προτιμότερος.


\section{Μελλοντική Εργασία}